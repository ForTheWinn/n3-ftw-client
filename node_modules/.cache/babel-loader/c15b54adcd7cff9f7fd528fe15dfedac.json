{"ast":null,"code":"import { u } from \"@cityofzion/neon-core\";\nimport { GAS_SCRIPT_HASH } from \"../../../consts\";\nimport { Network } from \"../../../network\";\nimport { NFT_CONTRACT_OWNER, NFT_SCRIPT_HASH } from \"./consts\";\nimport { wallet } from \"../../../index\";\nimport { parseProperties } from \"./helpers\";\nexport class NFTContract {\n  constructor(networkType) {\n    this.network = void 0;\n    this.contractHash = void 0;\n\n    this.mint = async connectedWallet => {\n      const invokeScript = {\n        operation: \"transfer\",\n        scriptHash: GAS_SCRIPT_HASH,\n        args: [{\n          type: \"Address\",\n          value: connectedWallet.account.address\n        }, {\n          type: \"Hash160\",\n          value: this.contractHash\n        }, {\n          type: \"Integer\",\n          value: 1000000000\n        }, {\n          type: \"String\",\n          value: \"1\"\n        }]\n      };\n      return new wallet.WalletAPI(connectedWallet.key).invoke(this.network, connectedWallet.account.address, invokeScript);\n    };\n\n    this.getTotalSupplyScript = () => {\n      return {\n        scriptHash: this.contractHash,\n        operation: \"totalSupply\",\n        args: []\n      };\n    };\n\n    this.getPropertiesScript = tokenId => {\n      // const tokenId = `${u.str2hexstring(prefix + no.toString())}`;\n      return {\n        scriptHash: this.contractHash,\n        operation: \"properties\",\n        args: [{\n          type: \"String\",\n          value: tokenId\n        }]\n      };\n    };\n\n    this.getProperties = async tokenId => {\n      const script = this.getPropertiesScript(tokenId);\n      const res = await Network.read(this.network, [script]); // @ts-ignore\n\n      return parseProperties(res.stack);\n    };\n\n    this.getTokensOfScript = ownerAddress => {\n      return {\n        scriptHash: this.contractHash,\n        operation: \"tokensOf\",\n        args: [{\n          type: \"Address\",\n          value: ownerAddress\n        }]\n      };\n    };\n\n    this.getTokensOf = async ownerAddress => {\n      const script = this.getTokensOfScript(ownerAddress);\n      const res = await Network.read(this.network, [script]);\n      const metaList = []; // @ts-ignore\n\n      for await (const item of res.stack[0].iterator) {\n        const tokenId = u.HexString.fromBase64(item.value).toAscii();\n        const meta = await this.getProperties(tokenId);\n        metaList.push(meta);\n      }\n\n      return metaList;\n    };\n\n    this.getTokens = async () => {\n      const script = {\n        scriptHash: this.contractHash,\n        operation: \"tokens\",\n        args: []\n      };\n      const res = await Network.read(this.network, [script]); // @ts-ignore\n\n      return res.stack[0].iterator.map(item => {\n        return u.HexString.fromBase64(item.value).toAscii();\n      });\n    };\n\n    this.network = networkType;\n    this.contractHash = NFT_SCRIPT_HASH[networkType];\n  }\n\n}\nNFTContract.owner = NFT_CONTRACT_OWNER;\nexport { NFT_SCRIPT_HASH } from \"./consts\";","map":{"version":3,"sources":["/Users/ed/Projects/n3-ftw/client/src/packages/neo/contracts/ftw/nft/index.ts"],"names":["u","GAS_SCRIPT_HASH","Network","NFT_CONTRACT_OWNER","NFT_SCRIPT_HASH","wallet","parseProperties","NFTContract","constructor","networkType","network","contractHash","mint","connectedWallet","invokeScript","operation","scriptHash","args","type","value","account","address","WalletAPI","key","invoke","getTotalSupplyScript","getPropertiesScript","tokenId","getProperties","script","res","read","stack","getTokensOfScript","ownerAddress","getTokensOf","metaList","item","iterator","HexString","fromBase64","toAscii","meta","push","getTokens","map","owner"],"mappings":"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","sourcesContent":["import { sc, u } from \"@cityofzion/neon-core\";\nimport { GAS_SCRIPT_HASH } from \"../../../consts\";\nimport { INetworkType, Network } from \"../../../network\";\nimport { NFT_CONTRACT_OWNER, NFT_SCRIPT_HASH } from \"./consts\";\nimport { IConnectedWallet } from \"../../../wallet/interfaces\";\nimport { wallet } from \"../../../index\";\nimport { IRuneMeta } from \"./interfaces\";\nimport { parseProperties } from \"./helpers\";\n\nexport class NFTContract {\n  network: INetworkType;\n  contractHash: string;\n\n  constructor(networkType: INetworkType) {\n    this.network = networkType;\n    this.contractHash = NFT_SCRIPT_HASH[networkType];\n  }\n\n  static owner = NFT_CONTRACT_OWNER;\n\n  mint = async (connectedWallet: IConnectedWallet): Promise<string> => {\n    const invokeScript = {\n      operation: \"transfer\",\n      scriptHash: GAS_SCRIPT_HASH,\n      args: [\n        {\n          type: \"Address\",\n          value: connectedWallet.account.address,\n        },\n        {\n          type: \"Hash160\",\n          value: this.contractHash,\n        },\n        {\n          type: \"Integer\",\n          value: 10_00000000,\n        },\n        {\n          type: \"String\",\n          value: \"1\",\n        },\n      ],\n    };\n    return new wallet.WalletAPI(connectedWallet.key).invoke(\n      this.network,\n      connectedWallet.account.address,\n      invokeScript\n    );\n  };\n\n  getTotalSupplyScript = (): sc.ContractCallJson => {\n    return {\n      scriptHash: this.contractHash,\n      operation: \"totalSupply\",\n      args: [],\n    };\n  };\n\n  getPropertiesScript = (tokenId: string) => {\n    // const tokenId = `${u.str2hexstring(prefix + no.toString())}`;\n    return {\n      scriptHash: this.contractHash,\n      operation: \"properties\",\n      args: [\n        {\n          type: \"String\",\n          value: tokenId,\n        },\n      ],\n    };\n  };\n\n  getProperties = async (tokenId: string): Promise<IRuneMeta> => {\n    const script = this.getPropertiesScript(tokenId);\n    const res = await Network.read(this.network, [script]);\n    // @ts-ignore\n    return parseProperties(res.stack);\n  };\n\n  getTokensOfScript = (ownerAddress: string) => {\n    return {\n      scriptHash: this.contractHash,\n      operation: \"tokensOf\",\n      args: [\n        {\n          type: \"Address\",\n          value: ownerAddress,\n        },\n      ],\n    };\n  };\n\n  getTokensOf = async (ownerAddress: string): Promise<object[]> => {\n    const script = this.getTokensOfScript(ownerAddress);\n    const res = await Network.read(this.network, [script]);\n    const metaList: object[] = [];\n    // @ts-ignore\n    for await (const item of res.stack[0].iterator) {\n      const tokenId = u.HexString.fromBase64(item.value as string).toAscii();\n      const meta = await this.getProperties(tokenId);\n      metaList.push(meta);\n    }\n    return metaList;\n  };\n\n  getTokens = async (): Promise<string[]> => {\n    const script = {\n      scriptHash: this.contractHash,\n      operation: \"tokens\",\n      args: [],\n    };\n    const res = await Network.read(this.network, [script]);\n    // @ts-ignore\n    return res.stack[0].iterator.map((item) => {\n      return u.HexString.fromBase64(item.value as string).toAscii();\n    });\n  };\n}\nexport { NFT_SCRIPT_HASH } from \"./consts\";\n"]},"metadata":{},"sourceType":"module"}