{"ast":null,"code":"import { rpc, sc, u } from \"@cityofzion/neon-core\";\nimport { MAINNET, MAINNET_CONFIG, PRIVATE_CONFIG, PRIVATENET, TESTNET, TESTNET_CONFIG } from \"../consts\";\nimport { convertContractCallParam } from \"../utils\";\nexport class Network {}\nNetwork.READ_LOG_FREQUENCY = 6000;\n\nNetwork.getRPCClient = networkType => {\n  let config;\n\n  switch (networkType) {\n    case PRIVATENET:\n      config = PRIVATE_CONFIG;\n      break;\n\n    case TESTNET:\n      config = TESTNET_CONFIG;\n      break;\n\n    case MAINNET:\n      config = MAINNET_CONFIG;\n      break;\n  }\n\n  return new rpc.RPCClient(config.url);\n};\n\nNetwork.findNotificationFromTxId = async (txId, scriptHash, eventName, networkType) => {\n  // Get transaction notifications\n  const notifications = await Network.getNotificationsFromTxId(txId, networkType); // Return selected one\n\n  return notifications.find(n => n.contract === \"0x\" + scriptHash && n.eventname === eventName);\n};\n\nNetwork.getNotificationsFromTxId = async (txId, network) => {\n  // Get rpc client to do calls\n  const rpcClient = Network.getRPCClient(network); // Cycle until i get app log to extract notifications from\n\n  let appLog;\n\n  do {\n    try {\n      appLog = await rpcClient.getApplicationLog(txId);\n    } catch (e) {\n      await Network.sleep(Network.READ_LOG_FREQUENCY);\n    }\n  } while (!appLog); // Get notifications from app log and return them\n\n\n  const notifications = [];\n  appLog.executions.forEach(e => {\n    notifications.push(...e.notifications);\n  });\n  return notifications;\n};\n\nNetwork.read = async (network, scripts) => {\n  const rpcClient = Network.getRPCClient(network);\n  const sb = new sc.ScriptBuilder();\n  scripts.map(script => {\n    let params = [];\n\n    if (script.args) {\n      params = script.args.map(arg => convertContractCallParam(arg));\n    }\n\n    sb.emitAppCall(script.scriptHash, script.operation, params);\n  });\n  const res = await rpcClient.invokeScript(u.HexString.fromHex(sb.build()));\n\n  if (res.state === \"FAULT\") {\n    console.error(\"RPC read error\" + res);\n    throw new Error(res.exception ? res.exception : \"Network error\");\n  }\n\n  return res;\n};\n\nNetwork.sleep = duration => {\n  return new Promise(resolve => {\n    setTimeout(resolve, duration);\n  });\n};","map":{"version":3,"sources":["/Users/ed/Projects/n3-ftw/client/src/packages/neo/network/index.ts"],"names":["rpc","sc","u","MAINNET","MAINNET_CONFIG","PRIVATE_CONFIG","PRIVATENET","TESTNET","TESTNET_CONFIG","convertContractCallParam","Network","READ_LOG_FREQUENCY","getRPCClient","networkType","config","RPCClient","url","findNotificationFromTxId","txId","scriptHash","eventName","notifications","getNotificationsFromTxId","find","n","contract","eventname","network","rpcClient","appLog","getApplicationLog","e","sleep","executions","forEach","push","read","scripts","sb","ScriptBuilder","map","script","params","args","arg","emitAppCall","operation","res","invokeScript","HexString","fromHex","build","state","console","error","Error","exception","duration","Promise","resolve","setTimeout"],"mappings":"AAAA,SAASA,GAAT,EAAcC,EAAd,EAAkBC,CAAlB,QAA2B,uBAA3B;AACA,SACEC,OADF,EAEEC,cAFF,EAGEC,cAHF,EAIEC,UAJF,EAKEC,OALF,EAMEC,cANF,QAOO,WAPP;AAUA,SAASC,wBAAT,QAAyC,UAAzC;AAIA,OAAO,MAAMC,OAAN,CAAc;AAARA,O,CACaC,kB,GAAqB,I;;AADlCD,O,CAGJE,Y,GAAgBC,WAAD,IAA+B;AACnD,MAAIC,MAAJ;;AACA,UAAQD,WAAR;AACE,SAAKP,UAAL;AACEQ,MAAAA,MAAM,GAAGT,cAAT;AACA;;AACF,SAAKE,OAAL;AACEO,MAAAA,MAAM,GAAGN,cAAT;AACA;;AACF,SAAKL,OAAL;AACEW,MAAAA,MAAM,GAAGV,cAAT;AACA;AATJ;;AAWA,SAAO,IAAIJ,GAAG,CAACe,SAAR,CAAkBD,MAAM,CAACE,GAAzB,CAAP;AACD,C;;AAjBUN,O,CAmBJO,wB,GAA2B,OAChCC,IADgC,EAEhCC,UAFgC,EAGhCC,SAHgC,EAIhCP,WAJgC,KAK7B;AACH;AACA,QAAMQ,aAAa,GAAG,MAAMX,OAAO,CAACY,wBAAR,CAC1BJ,IAD0B,EAE1BL,WAF0B,CAA5B,CAFG,CAMH;;AACA,SAAOQ,aAAa,CAACE,IAAd,CACJC,CAAD,IAAYA,CAAC,CAACC,QAAF,KAAe,OAAON,UAAtB,IAAoCK,CAAC,CAACE,SAAF,KAAgBN,SAD3D,CAAP;AAGD,C;;AAlCUV,O,CAoCJY,wB,GAA2B,OAChCJ,IADgC,EAEhCS,OAFgC,KAG7B;AACH;AACA,QAAMC,SAAS,GAAGlB,OAAO,CAACE,YAAR,CAAqBe,OAArB,CAAlB,CAFG,CAIH;;AACA,MAAIE,MAAJ;;AACA,KAAG;AACD,QAAI;AACFA,MAAAA,MAAM,GAAG,MAAMD,SAAS,CAACE,iBAAV,CAA4BZ,IAA5B,CAAf;AACD,KAFD,CAEE,OAAOa,CAAP,EAAU;AACV,YAAMrB,OAAO,CAACsB,KAAR,CAActB,OAAO,CAACC,kBAAtB,CAAN;AACD;AACF,GAND,QAMS,CAACkB,MANV,EANG,CAcH;;;AACA,QAAMR,aAAa,GAAG,EAAtB;AACAQ,EAAAA,MAAM,CAACI,UAAP,CAAkBC,OAAlB,CAA2BH,CAAD,IAAO;AAC/BV,IAAAA,aAAa,CAACc,IAAd,CAAmB,GAAGJ,CAAC,CAACV,aAAxB;AACD,GAFD;AAGA,SAAOA,aAAP;AACD,C;;AA3DUX,O,CA6DJ0B,I,GAAO,OACZT,OADY,EAEZU,OAFY,KAGc;AAC1B,QAAMT,SAAS,GAAGlB,OAAO,CAACE,YAAR,CAAqBe,OAArB,CAAlB;AACA,QAAMW,EAAE,GAAG,IAAIrC,EAAE,CAACsC,aAAP,EAAX;AACAF,EAAAA,OAAO,CAACG,GAAR,CAAaC,MAAD,IAAY;AACtB,QAAIC,MAAiB,GAAG,EAAxB;;AACA,QAAID,MAAM,CAACE,IAAX,EAAiB;AACfD,MAAAA,MAAM,GAAGD,MAAM,CAACE,IAAP,CAAYH,GAAZ,CAAiBI,GAAD,IAASnC,wBAAwB,CAACmC,GAAD,CAAjD,CAAT;AACD;;AACDN,IAAAA,EAAE,CAACO,WAAH,CAAeJ,MAAM,CAACtB,UAAtB,EAAkCsB,MAAM,CAACK,SAAzC,EAAoDJ,MAApD;AACD,GAND;AAOA,QAAMK,GAAG,GAAG,MAAMnB,SAAS,CAACoB,YAAV,CAAuB9C,CAAC,CAAC+C,SAAF,CAAYC,OAAZ,CAAoBZ,EAAE,CAACa,KAAH,EAApB,CAAvB,CAAlB;;AACA,MAAIJ,GAAG,CAACK,KAAJ,KAAc,OAAlB,EAA2B;AACzBC,IAAAA,OAAO,CAACC,KAAR,CAAc,mBAAmBP,GAAjC;AACA,UAAM,IAAIQ,KAAJ,CAAUR,GAAG,CAACS,SAAJ,GAAgBT,GAAG,CAACS,SAApB,GAAgC,eAA1C,CAAN;AACD;;AACD,SAAOT,GAAP;AACD,C;;AAhFUrC,O,CAkFJsB,K,GAASyB,QAAD,IAAsB;AACnC,SAAO,IAAIC,OAAJ,CAAaC,OAAD,IAAa;AAC9BC,IAAAA,UAAU,CAACD,OAAD,EAAUF,QAAV,CAAV;AACD,GAFM,CAAP;AAGD,C","sourcesContent":["import { rpc, sc, u } from \"@cityofzion/neon-core\";\nimport {\n  MAINNET,\n  MAINNET_CONFIG,\n  PRIVATE_CONFIG,\n  PRIVATENET,\n  TESTNET,\n  TESTNET_CONFIG,\n} from \"../consts\";\nimport { InvokeResult } from \"@cityofzion/neon-core/lib/rpc\";\nimport { ApplicationLogJson } from \"@cityofzion/neon-core/lib/rpc/Query\";\nimport { convertContractCallParam } from \"../utils\";\n\nexport type INetworkType = typeof PRIVATENET | typeof MAINNET | typeof TESTNET;\n\nexport class Network {\n  private static readonly READ_LOG_FREQUENCY = 6000;\n\n  static getRPCClient = (networkType: INetworkType) => {\n    let config;\n    switch (networkType) {\n      case PRIVATENET:\n        config = PRIVATE_CONFIG;\n        break;\n      case TESTNET:\n        config = TESTNET_CONFIG;\n        break;\n      case MAINNET:\n        config = MAINNET_CONFIG;\n        break;\n    }\n    return new rpc.RPCClient(config.url);\n  };\n\n  static findNotificationFromTxId = async (\n    txId: string,\n    scriptHash: string,\n    eventName: string,\n    networkType: INetworkType\n  ) => {\n    // Get transaction notifications\n    const notifications = await Network.getNotificationsFromTxId(\n      txId,\n      networkType\n    );\n    // Return selected one\n    return notifications.find(\n      (n: any) => n.contract === \"0x\" + scriptHash && n.eventname === eventName\n    );\n  };\n\n  static getNotificationsFromTxId = async (\n    txId: string,\n    network: INetworkType\n  ) => {\n    // Get rpc client to do calls\n    const rpcClient = Network.getRPCClient(network);\n\n    // Cycle until i get app log to extract notifications from\n    let appLog: ApplicationLogJson | undefined;\n    do {\n      try {\n        appLog = await rpcClient.getApplicationLog(txId);\n      } catch (e) {\n        await Network.sleep(Network.READ_LOG_FREQUENCY);\n      }\n    } while (!appLog);\n\n    // Get notifications from app log and return them\n    const notifications = [] as any;\n    appLog.executions.forEach((e) => {\n      notifications.push(...e.notifications);\n    });\n    return notifications;\n  };\n\n  static read = async (\n    network: INetworkType,\n    scripts: sc.ContractCallJson[]\n  ): Promise<InvokeResult> => {\n    const rpcClient = Network.getRPCClient(network);\n    const sb = new sc.ScriptBuilder();\n    scripts.map((script) => {\n      let params: unknown[] = [];\n      if (script.args) {\n        params = script.args.map((arg) => convertContractCallParam(arg));\n      }\n      sb.emitAppCall(script.scriptHash, script.operation, params);\n    });\n    const res = await rpcClient.invokeScript(u.HexString.fromHex(sb.build()));\n    if (res.state === \"FAULT\") {\n      console.error(\"RPC read error\" + res);\n      throw new Error(res.exception ? res.exception : \"Network error\");\n    }\n    return res;\n  };\n\n  static sleep = (duration: number) => {\n    return new Promise((resolve) => {\n      setTimeout(resolve, duration);\n    });\n  };\n}\n"]},"metadata":{},"sourceType":"module"}